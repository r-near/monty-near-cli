// NEAR contract runtime for Monty (Python) smart contracts.
//
// Auto-generated by monty-near-cli. The runtime code below is static; only the
// bytecode statics and export functions (between the marker comments) are
// generated per-contract.

use monty::{MontyObject, MontyRun, NoLimitTracker, NoPrint, RunProgress};

// ---------------------------------------------------------------------------
// Custom getrandom backend â€” uses NEAR's VRF randomness
// ---------------------------------------------------------------------------

#[no_mangle]
unsafe extern "Rust" fn __getrandom_v03_custom(
    dest: *mut u8,
    len: usize,
) -> Result<(), getrandom::Error> {
    unsafe {
        random_seed(0);
        let seed_len = register_len(0) as usize;
        let mut seed = [0u8; 32];
        read_register(0, seed.as_mut_ptr() as u64);

        let dest_slice = core::slice::from_raw_parts_mut(dest, len);
        for (i, byte) in dest_slice.iter_mut().enumerate() {
            *byte = seed[i % seed_len];
        }
    }
    Ok(())
}

// ---------------------------------------------------------------------------
// NEAR host function imports
// ---------------------------------------------------------------------------

#[link(wasm_import_module = "env")]
extern "C" {
    fn register_len(register_id: u64) -> u64;
    fn read_register(register_id: u64, ptr: u64);

    fn input(register_id: u64);
    fn current_account_id(register_id: u64);
    fn predecessor_account_id(register_id: u64);
    fn signer_account_id(register_id: u64);
    fn block_index() -> u64;
    fn block_timestamp() -> u64;

    fn storage_write(
        key_len: u64,
        key_ptr: u64,
        value_len: u64,
        value_ptr: u64,
        register_id: u64,
    ) -> u64;
    fn storage_read(key_len: u64, key_ptr: u64, register_id: u64) -> u64;
    fn storage_remove(key_len: u64, key_ptr: u64, register_id: u64) -> u64;
    fn storage_has_key(key_len: u64, key_ptr: u64) -> u64;

    fn sha256(value_len: u64, value_ptr: u64, register_id: u64);
    fn keccak256(value_len: u64, value_ptr: u64, register_id: u64);

    fn random_seed(register_id: u64);

    fn value_return(value_len: u64, value_ptr: u64);
    fn log_utf8(len: u64, ptr: u64);
}

// ---------------------------------------------------------------------------
// NEAR host function wrappers
// ---------------------------------------------------------------------------

fn near_input() -> Vec<u8> {
    unsafe {
        input(0);
        let len = register_len(0);
        if len == u64::MAX {
            return Vec::new();
        }
        let mut buf = vec![0u8; len as usize];
        read_register(0, buf.as_mut_ptr() as u64);
        buf
    }
}

fn near_value_return(data: &[u8]) {
    unsafe {
        value_return(data.len() as u64, data.as_ptr() as u64);
    }
}

fn near_log(msg: &str) {
    unsafe {
        log_utf8(msg.len() as u64, msg.as_ptr() as u64);
    }
}

fn near_read_register_bytes(register_id: u64) -> Vec<u8> {
    unsafe {
        let len = register_len(register_id);
        let mut buf = vec![0u8; len as usize];
        read_register(register_id, buf.as_mut_ptr() as u64);
        buf
    }
}

fn near_read_register_string(register_id: u64) -> String {
    String::from_utf8(near_read_register_bytes(register_id)).unwrap_or_default()
}

fn near_storage_write(key: &[u8], value: &[u8]) -> bool {
    unsafe {
        storage_write(
            key.len() as u64,
            key.as_ptr() as u64,
            value.len() as u64,
            value.as_ptr() as u64,
            0,
        ) == 1
    }
}

fn near_storage_read(key: &[u8]) -> Option<Vec<u8>> {
    unsafe {
        if storage_read(key.len() as u64, key.as_ptr() as u64, 0) == 1 {
            Some(near_read_register_bytes(0))
        } else {
            None
        }
    }
}

fn near_storage_remove(key: &[u8]) -> bool {
    unsafe { storage_remove(key.len() as u64, key.as_ptr() as u64, 0) == 1 }
}

fn near_storage_has_key(key: &[u8]) -> bool {
    unsafe { storage_has_key(key.len() as u64, key.as_ptr() as u64) == 1 }
}

fn near_current_account_id() -> String {
    unsafe {
        current_account_id(0);
    }
    near_read_register_string(0)
}

fn near_predecessor_account_id() -> String {
    unsafe {
        predecessor_account_id(0);
    }
    near_read_register_string(0)
}

fn near_signer_account_id() -> String {
    unsafe {
        signer_account_id(0);
    }
    near_read_register_string(0)
}

fn near_block_height() -> u64 {
    unsafe { block_index() }
}

fn near_block_timestamp() -> u64 {
    unsafe { block_timestamp() }
}

fn near_sha256(data: &[u8]) -> Vec<u8> {
    unsafe {
        sha256(data.len() as u64, data.as_ptr() as u64, 0);
    }
    near_read_register_bytes(0)
}

fn near_keccak256(data: &[u8]) -> Vec<u8> {
    unsafe {
        keccak256(data.len() as u64, data.as_ptr() as u64, 0);
    }
    near_read_register_bytes(0)
}

fn to_hex(bytes: &[u8]) -> String {
    let mut hex = String::with_capacity(bytes.len() * 2);
    for b in bytes {
        use core::fmt::Write;
        let _ = write!(hex, "{b:02x}");
    }
    hex
}

// ---------------------------------------------------------------------------
// Python contract execution engine
// ---------------------------------------------------------------------------

fn run_precompiled(bytecode: &[u8]) {
    let runner = MontyRun::load(bytecode).unwrap_or_else(|e| {
        near_log(&format!("monty load error: {e}"));
        panic!("monty load error");
    });

    let mut print = NoPrint;

    let mut progress = runner
        .start(vec![], NoLimitTracker, &mut print)
        .unwrap_or_else(|e| {
            near_log(&format!("monty start error: {e}"));
            panic!("monty start error");
        });

    loop {
        match progress {
            RunProgress::FunctionCall {
                function_name,
                args,
                state,
                ..
            } => {
                let result = dispatch_function(&function_name, &args);
                progress = state.run(result, &mut print).unwrap_or_else(|e| {
                    near_log(&format!("monty runtime error: {e}"));
                    panic!("monty runtime error");
                });
            }
            RunProgress::Complete(_) => break,
            RunProgress::OsCall { .. } => {
                near_log("OS calls are not permitted in NEAR contracts");
                panic!("OS call attempted");
            }
            RunProgress::ResolveFutures(_) => {
                near_log("Async futures are not supported in NEAR contracts");
                panic!("async futures not supported");
            }
        }
    }
}

fn dispatch_function(name: &str, args: &[MontyObject]) -> MontyObject {
    match name {
        "value_return" => {
            let s = match args.first() {
                Some(MontyObject::String(s)) => s.as_bytes(),
                Some(MontyObject::Bytes(b)) => b.as_slice(),
                Some(other) => {
                    let repr = format!("{other:?}");
                    near_value_return(repr.as_bytes());
                    return MontyObject::None;
                }
                None => b"",
            };
            near_value_return(s);
            MontyObject::None
        }
        "input" => {
            let data = near_input();
            match String::from_utf8(data) {
                Ok(s) => MontyObject::String(s),
                Err(e) => MontyObject::Bytes(e.into_bytes()),
            }
        }
        "log" => {
            let msg = match args.first() {
                Some(MontyObject::String(s)) => s.clone(),
                Some(other) => format!("{other:?}"),
                None => String::new(),
            };
            near_log(&msg);
            MontyObject::None
        }

        "storage_write" => {
            let key = match args.first() {
                Some(MontyObject::String(s)) => s.as_bytes(),
                _ => return MontyObject::None,
            };
            let value = match args.get(1) {
                Some(MontyObject::String(s)) => s.as_bytes(),
                _ => return MontyObject::None,
            };
            MontyObject::Bool(near_storage_write(key, value))
        }
        "storage_read" => {
            let key = match args.first() {
                Some(MontyObject::String(s)) => s.as_bytes(),
                _ => return MontyObject::None,
            };
            match near_storage_read(key) {
                Some(bytes) => MontyObject::String(String::from_utf8(bytes).unwrap_or_default()),
                None => MontyObject::None,
            }
        }
        "storage_remove" => {
            let key = match args.first() {
                Some(MontyObject::String(s)) => s.as_bytes(),
                _ => return MontyObject::None,
            };
            MontyObject::Bool(near_storage_remove(key))
        }
        "storage_has_key" => {
            let key = match args.first() {
                Some(MontyObject::String(s)) => s.as_bytes(),
                _ => return MontyObject::None,
            };
            MontyObject::Bool(near_storage_has_key(key))
        }

        "current_account_id" => MontyObject::String(near_current_account_id()),
        "predecessor_account_id" => MontyObject::String(near_predecessor_account_id()),
        "signer_account_id" => MontyObject::String(near_signer_account_id()),
        "block_height" => MontyObject::Int(near_block_height() as i64),
        "block_timestamp" => MontyObject::Int(near_block_timestamp() as i64),

        "sha256" => {
            let data = match args.first() {
                Some(MontyObject::String(s)) => s.as_bytes(),
                Some(MontyObject::Bytes(b)) => b.as_slice(),
                _ => return MontyObject::None,
            };
            MontyObject::String(to_hex(&near_sha256(data)))
        }
        "keccak256" => {
            let data = match args.first() {
                Some(MontyObject::String(s)) => s.as_bytes(),
                Some(MontyObject::Bytes(b)) => b.as_slice(),
                _ => return MontyObject::None,
            };
            MontyObject::String(to_hex(&near_keccak256(data)))
        }

        _ => {
            near_log(&format!("unknown external function: {name}"));
            MontyObject::None
        }
    }
}

// ---------------------------------------------------------------------------
// Pre-compiled bytecode (generated by monty-near-cli)
// ---------------------------------------------------------------------------
// @MONTY_BYTECODE_STATICS

// ---------------------------------------------------------------------------
// NEAR contract exports (generated by monty-near-cli)
// ---------------------------------------------------------------------------
// @MONTY_EXPORTS
